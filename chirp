#! /usr/bin/env python

from ConfigParser import ConfigParser
from optparse import OptionParser
from sys import argv, exit
from os.path import expanduser
from termcolor import colored

try :
    import twitter
except ImportError :
    print "You don't have the python-twitter library needed to use chirp."
    exit(1)


ACTIONS = set([
    'post',
    'list',
    'direct',
    'debug',
])

def parseOptions(argv) :
    '''Does command line parsing of options.'''
    parser = OptionParser()

    parser.add_option('-u', '--username',
                      action = 'store',
                      dest   = 'username')

    parser.add_option('-p', '--password',
                      action = 'store',
                      dest   = 'password')

    parser.add_option('-c', '--color',
                      action = 'store_true',
                      dest   = 'color')

    options, args = parser.parse_args(argv[1:])

    # Validation of actions.

    # No Action. Barring options, the action should be the first thing on the
    # line after 'chirp' or equivalent.

    try :
        options.action = args.pop(0)
    except IndexError :
        print "Must specify an action."
        exit(1)

    # Invalid Action
    if options.action not in ACTIONS :
        print "Action must be one of : ", ACTIONS
        exit(1)

    # No target for 'list' and 'direct' actions.
    if options.action in set(['list', 'direct']) :
        try :
            options.target = args.pop(0)
        except IndexError :
            print "The 'list' and 'direct' actions require a target."
            exit(1)

    return options, args

def initAPI() :
    parser = ConfigParser()
    parser.read('%s/.chirprc' % expanduser('~'))

    api = twitter.Api(parser.get('authentication', 'username'),
                      parser.get('authentication', 'password'))

    return api

def main() :
    options, args = parseOptions(argv)

    api = initAPI()

    if options.action == 'update' :
        if args :
            status = args[0]
        else :
            status = []
            while True :
                try :
                    status.append(raw_input())
                except EOFError :
                    break

            status = '\n'.join(status)

        if len(status) > 140 :
            print "Message is too long, must be less than 140 characters."
            print "Current message is %d characters long." % len(status)
        else :
            api.PostUpdate(status)
            print "Posted update."
    elif options.action == 'list' :
        timeline = api.GetUserTimeline(user = options.list_arg)
        for status in timeline :
            print "-", status.GetText()
            print "\t- ", status.GetRelativeCreatedAt()

    elif options.action == 'list' :
        timeline = api.GetUserTimeline(user = options.list_arg)
        for status in timeline :
            print colored(status.user.screen_name, 'blue'), "-", colored(status.GetText(), 'yellow')
            print "\t- ", status.GetRelativeCreatedAt()

    elif options.action == 'replies':
        replies = api.GetReplies()
        for status in replies:
            print status.user.screen_name, "-", status.GetText()
            print "\t- ", status.GetRelativeCreatedAt()

    elif options.action == 'test' :
        print args

    return

if __name__ == '__main__' :
    main()

